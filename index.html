<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Blocks</title>
<style>
    body {
        margin: 0;
        background: black;
        overflow: hidden;
    }
    canvas {
        display: block;
    }
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// ----- 設定 -----
const BLOCK_COUNT = 50;
const BLOCK_SIZE = 70;
const FONT = "bold 38px monospace";
const NUM_FONT = "bold 22px monospace";
const MIN_WAIT = 1000; // 1秒
const MAX_WAIT = 2000; // 2秒

// ----- ブロック生成 -----
function randomLetter() {
    const a = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    return a[Math.floor(Math.random() * a.length)];
}

function randomNumber() {
    return String(Math.floor(100 + Math.random() * 900)); // 3桁
}

// 重ならない位置を作る
function generateNonOverlapPositions() {
    const blocks = [];
    const margin = 10;

    for (let i = 0; i < BLOCK_COUNT; i++) {
        let x, y;
        let ok = false;

        while (!ok) {
            x = Math.random() * (canvas.width - BLOCK_SIZE - 50) + 25;
            y = Math.random() * (canvas.height - BLOCK_SIZE - 50) + 25;

            ok = true;
            for (const b of blocks) {
                const dx = b.x - x;
                const dy = b.y - y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < BLOCK_SIZE + margin) {
                    ok = false;
                    break;
                }
            }
        }

        const angle = (Math.random() * 40 - 40) * Math.PI / 180;

        blocks.push({
            x,
            y,
            angle,
            letter: randomLetter(),
            number: randomNumber(),
            numOffset: 0,
            state: "top",
            timer: Date.now(),
            wait: Math.random() * (MAX_WAIT - MIN_WAIT) + MIN_WAIT
        });
    }

    return blocks;
}

const blocks = generateNonOverlapPositions();

// ----- 描画 -----
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    for (const b of blocks) {

        // アニメ制御
        const now = Date.now();

        if (b.state === "top") {
            if (now - b.timer >= b.wait) {
                b.state = "goingDown";
            }
        }

        if (b.state === "goingDown") {
            b.numOffset += 2;
            if (b.numOffset >= BLOCK_SIZE * 0.9) {
                b.numOffset = BLOCK_SIZE * 0.9;
                b.state = "hiddenWait";
                b.timer = now;
                b.wait = Math.random() * (MAX_WAIT - MIN_WAIT) + MIN_WAIT;
            }
        }

        if (b.state === "hiddenWait") {
            if (now - b.timer >= b.wait) {
                b.state = "goingUp";
            }
        }

        if (b.state === "goingUp") {
            b.numOffset -= 2;
            if (b.numOffset <= 0) {
                b.numOffset = 0;
                b.state = "top";
                b.timer = now;
                b.wait = Math.random() * (MAX_WAIT - MIN_WAIT) + MIN_WAIT;
            }
        }

        // ----- 描画 -----
        ctx.save();
        ctx.translate(b.x, b.y);
        ctx.rotate(b.angle);

        ctx.strokeStyle = "white";
        ctx.lineWidth = 3;

        ctx.strokeRect(-BLOCK_SIZE / 2, -BLOCK_SIZE / 2, BLOCK_SIZE, BLOCK_SIZE);

        ctx.fillStyle = "white";
        ctx.font = FONT;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(b.letter, 0, 5);

        // 数字（完全に隠れる）
        ctx.font = NUM_FONT;
        ctx.fillText(b.number, 0, -BLOCK_SIZE / 2 - 10 + b.numOffset);

        ctx.restore();
    }

    requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>
